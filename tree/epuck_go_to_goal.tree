// world: A  <--100--> B where A = 0 and B = 100
// robot: r, load:l
// 3 points => robot point and initial target point and final target point.
// the goal is to take the load from initial target point into final target point
// 1 - head off to the initial target
//  -- select right direction
//  -- keep moving until the distance will be 0
// 2 - pick up the load
// 3 - move to the final point
//  -- select the right direction
//  -- keep moving until the distance will be 0
// 4 - place the load
// bb:
// init_coord: where the robot is spawned like 10
// load_coord: where the load is spawned like 80
// targ_coord: where the load should be delivered like 20
// size: the size from A to B

import "std::actions"

root main sequence {    
    init()
    define_direction(target)
    retry(0) sequence {
        step()     
        inverter moving()
    }
    
    simulation(reset)
    wait(1.0)
}

r_sequence init {
    store("wall","wall")
    store("reset","reset")
    store("left","left")
    store("right","right")
    store("backward","backward")
    store("forward","forward")
    store("drive","drive")
    store("target", 0)
    init_robot()
    init_pid()
    wait(0.5)
}

sequence moving() {  
    move(drive)
    fallback {
        inverter is_arrived(target)
        move(stop)
        define_direction(target)
    }  
}

impl init_robot();
impl wait(sec:num);
impl collision(target:string);
impl turn(angle:num, with_random:bool);
impl move(target:string);
impl step();
impl simulation(op:string);

impl define_direction(target:num);
impl is_arrived(target:num);
impl init_pid();
